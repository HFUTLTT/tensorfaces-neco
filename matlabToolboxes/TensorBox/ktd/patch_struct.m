function patch_param = patch_struct(options)
% Structures of patches are set by the subroutine "patch_struct".
% Namely, patch sizes, type of constraints and optimization problem
% 
% For example, an approximation term with the second patches of size [8 8 3], 
% is with sparsity constraint on DCT domain
%
%       Patch_Opt = patch_struct;
%       Patch_Opt.Size = {[32 32 1] [8 8 3]};
%       Patch_Opt.Constraints = 'sparse';
%       Patch_Opt.Transform = 'dct';
%
% An approximation term with patches  [32 32 1] x [8 8 3] is with
% rank-minimal constraints 
%
%       Patch_Opt = patch_struct;
%       Patch_Opt.Size = {[32 32 1] [8 8 3]};
%       Patch_Opt.Constraints = 'lowrank';
%
% An approximation term with patches  [4 4 1] x [8 8  1] x [8 8 3] is with
% rank of 50
%
%       Patch_Opt = patch_struct;
%       Patch_Opt.Size = {[4 4 1] [8 8 1] [8 8 3]};
%       Patch_Opt.Constraints = 'lowrank';
%       Patch_Opt.NoComps = 50;

% Phan Anh Huy, 2015
if ~exist('options','var'), options = struct; end

if ischar(options)
    switch options
        case 'lowrankdenoise'
            options = struct('Constraints','lowrank','solver','snc');
        case 'lowrank'
            options = struct('Constraints','lowrank','solver','nc');
        case 'sparse'
            options = struct('Constraints','sparse','solver','omp','Transform','dct');
    end
    
end

patch_param = inputParser;
patch_param.KeepUnmatched = true;
patch_param.addOptional('Size',[]);
patch_param.addOptional('Transform','none'); %none, or 'dct' 'walsh' 'coif','db'...
patch_param.addOptional('NoComps','none'); % Used for low rank matrix/tensor approximations
patch_param.addOptional('Constraints','lowrank',@(x) ismember(x,{'lowrank' 'sparse'})); % rank minimization or sparse constraints. Used for constrained matrix approximation
patch_param.addOptional('Regularized_par',1); % regularized patch_parameters for constrained matrix approximations

patch_param.addOptional('solver','omp',@(x) ismember(x,{'omp' 'lasso' 'bpdn' 'nc' 'snc' 'cpd'})); % solver for approximation term


patch_param.addOptional('orthogonal_term',true); % true if this approximation term is orthogonal to the others.

patch_param.addOptional('TF',[]);  % forward transform. Don't need to set this field, and it will be generated by sub-routines in KTDO.
patch_param.addOptional('iTF',[]); % inverse transform. Don't need to set this field, and it will be generated by sub-routines in KTDO.
patch_param.parse(options);
patch_param = patch_param.Results;
